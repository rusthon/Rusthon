<html>
	<head>
		<meta charset="utf-8">


<link href='~/js/css/bootstrap.css' rel='stylesheet' />
<link href='~/js/css/darkstrap.css' rel='stylesheet' />

<style>
	body {
		background: rgb(43,45,48); /* Old browsers */
		background: -moz-radial-gradient(center, ellipse cover,  rgba(43,45,48,1) 0%, rgba(0,0,0,1) 100%); /* FF3.6+ */
		background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,rgba(43,45,48,1)), color-stop(100%,rgba(0,0,0,1))); /* Chrome,Safari4+ */
		background: -webkit-radial-gradient(center, ellipse cover,  rgba(43,45,48,1) 0%,rgba(0,0,0,1) 100%); /* Chrome10+,Safari5.1+ */
		background: -o-radial-gradient(center, ellipse cover,  rgba(43,45,48,1) 0%,rgba(0,0,0,1) 100%); /* Opera 12+ */
		background: -ms-radial-gradient(center, ellipse cover,  rgba(43,45,48,1) 0%,rgba(0,0,0,1) 100%); /* IE10+ */
		background: radial-gradient(ellipse at center,  rgba(43,45,48,1) 0%,rgba(0,0,0,1) 100%); /* W3C */

		margin: 0;
		font-family: Arial;
		overflow: hidden;

	}
</style>

<script src="~/js/jquery/jquery-latest.js"></script>
<script src="~/js/bootstrap/bootstrap.min.js"></script>

	</head>
	<body>
		<script src="~/three.js/build/three.min.js"></script>

		<script src="~/three.js/examples/js/controls/TrackballControls.js"></script>
		<script src="~/three.js/examples/js/controls/TransformControls.js"></script>

		<script src="~/three.js/examples/js/renderers/CSS3DRenderer.js"></script>

		<script src="~/three.js/examples/js/postprocessing/RenderPass.js"></script>
		<script src="~/three.js/examples/js/postprocessing/ShaderPass.js"></script>
		<script src="~/three.js/examples/js/postprocessing/EffectComposer.js"></script>


		<script src="~/three.js/examples/js/postprocessing/BloomPass.js"></script>
		<script src="~/three.js/examples/js/postprocessing/ShaderPass.js"></script>
		<script src="~/three.js/examples/js/postprocessing/MaskPass.js"></script>
		<script src="~/three.js/examples/js/postprocessing/SavePass.js"></script>

		<script src="~/three.js/examples/js/shaders/ConvolutionShader.js"></script>
		<script src="~/three.js/examples/js/shaders/CopyShader.js"></script>
		<script src="~/three.js/examples/js/shaders/FXAAShader.js"></script>
		<script src="~/three.js/examples/js/shaders/HorizontalTiltShiftShader.js"></script>
		<script src="~/three.js/examples/js/shaders/VerticalTiltShiftShader.js"></script>
		<script src="~/three.js/examples/js/shaders/VignetteShader.js"></script>
		<script src="~/three.js/examples/js/shaders/EdgeShader2.js"></script>

		<script type="text/python">

pythonjs.configure(javascript=True)
from random import random


__sid = 0

def create_textarea():
	global __sid
	__sid += 1
	ta = document.createElement('textarea')
	ta.setAttribute('id', '__sid'+__sid)
	def func(): ta.focus()  ## this allows normal keyboard input
	ta.onclick = func
	ta.style.backgroundColor = 'black'
	ta.style.color = 'green'
	ta.style.fontWeight = 'bold'
	ta.setAttribute('class', 'focused alert alert-info')
	return ta


class Element3D:
	def __init__(self, element, scene, shadow_scene, interact_scene, position, scale ):
		## required for select dropdowns because `selectedIndex` is not updated by `e.cloneNode()` ##
		self._sid = 0
		self.interact_scene = interact_scene
		self.shadow_scene = shadow_scene
		self.object = object = new THREE.CSS3DObject( element )
		self.position = object.position
		self.rotation = object.rotation
		self.scale = object.scale

		self.shadow = new THREE.CSS3DObject( element.cloneNode() )
		self.element = element
		self.active = False

		## shadow_images is required because every frame the entire dom is cloned to be rendered under webgl layer,
		## image data is lazy loaded, so even if the image is shown on the top interactive layer and cloned,
		## it still takes time before the clone will lazy load the image data,
		## below shadow_images holds a mapping of url and image, these must be inserted into the cloned dom each update.
		self.shadow_images = {}

		self.dropdown = None

		x,y,z = position
		self.object.position.set(x,y,z+1)
		self.shadow.position.set(x,y,z)

		x,y,z = scale
		self.object.scale.set(x,y,z)
		self.shadow.scale.set(x,y,z)

		shadow_scene.add( self.shadow )
		interact_scene.add( self.object )

		self.root = new THREE.Object3D()
		scene.add( self.root )

		self.create_windowframe()

	def display_dropdown(self, e, options):
		if not self.dropdown:
			self.create_dropdown( e, options )
		else:
			self.object.remove( self.dropdown )
			self.shadow.remove( self.dropdown_clone )
			self.root.remove( self._ddmesh1 )
			self.root.remove( self._ddmesh2 )
			self.dropdown = None

	def hide_dropdown(self):  ## not working, three.js bug?
		self.dropdown.visible = false
		self.dropdown_clone.visible = false


	def create_dropdown(self, e, options):
		global sel
		sel = document.createElement('select')
		sel.setAttribute('multiple', 'multiple')
		self._sid += 1
		sel.setAttribute('id', '_sid'+self._sid)
		for i,opt in enumerate(options):
			o = document.createElement('option')
			o.setAttribute('index', i)
			o.appendChild( document.createTextNode(opt) )
			sel.appendChild( o )

		##print('clientHeight', sel.clientHeight)
		## sel.clientHeight can not be used here because the dom has not been updated,
		## as a simple workaround guess height based on number of options,
		## this needs to be done anyways because `sel` must be given a height in pixels,
		## to force it to display all the options, and not display a scroll bar (which are not synced).
		H = 18 * options.length
		if H < 150: H = 150
		sel.style.height = H #'100%'

		## create dropdown css object and add it to self.object,
		## this makes it part of the interactive scene,
		## it is also needs its own shadow clone to be updated.
		self.dropdown = new THREE.CSS3DObject( sel )
		self.object.add( self.dropdown )
		self.dropdown_clone = new THREE.CSS3DObject(sel.cloneNode())
		self.shadow.add( self.dropdown_clone )

		self.dropdown.position.x = e.offsetLeft / 2
		self.dropdown.position.y -= (H/2) - e.offsetTop
		self.dropdown.position.z += 20
		self.dropdown_clone.position.copy( self.dropdown.position )
		self.dropdown_clone.position.z -= 1

		sel.focus()
		def onclick(evt):
			#sel.focus()  ## this triggers a bug that offsets the interactive layer
			print(evt.toElement.getAttribute('index'))
			e.selectedIndex = sel.selectedIndex = int(evt.toElement.getAttribute('index'))
		sel.onclick = onclick



		geo = new THREE.BoxGeometry( 1.1, H*1.1, 3 );
		mat = new THREE.MeshBasicMaterial( {'color': 0x00ffff, 'transparent':true, 'opacity':0.18, 'blending':THREE.AdditiveBlending } );
		self._ddmesh1 = m = new THREE.Mesh( geo, mat );
		self.root.add( m );
		m.castShadow = true;
		m.position.x = e.offsetLeft / 2
		m.position.y -= (H/2) - e.offsetTop
		m.position.y += 10
		m.position.z = 1
		m.scale.x = e.clientWidth

		geo = new THREE.BoxGeometry( 1.07, H, 3 );
		mat = new THREE.MeshBasicMaterial( {'color': 0xffffff, 'transparent':true, 'opacity':0.48, 'blending':THREE.SubtractiveBlending } );
		self._ddmesh2 = m = new THREE.Mesh( geo, mat );
		self.root.add( m );
		m.castShadow = true;
		m.position.x = e.offsetLeft / 2
		m.position.y -= (H/2) - e.offsetTop
		m.position.y += 10
		m.position.z = 15
		m.scale.x = e.clientWidth


	def create_select_dropdown(self, options ):
		self._sid += 1
		a = document.createElement('select')
		a.setAttribute('id', '_sid'+self._sid)

		def onclick(e):
			a.focus()  ## allows the enter key to display options
			self.display_dropdown(a, options)
		a.onclick = onclick.bind(self)

		for opt in options:
			o = document.createElement('option')
			o.appendChild(document.createTextNode(opt))
			a.appendChild(o)

		return a


	def create_windowframe(self):
		geo = new THREE.BoxGeometry( 1, 1, 1 );
		mat = new THREE.MeshBasicMaterial( color=0x000000, opacity=0 )
		mat.blending = THREE.NoBlending
		self.mask = r = new THREE.Mesh( geo, mat );
		self.root.add( r );
		#r.position.copy( self.object.position )
		r.position.z -= 5

		geo = new THREE.BoxGeometry( 0.7, 1, 20 );
		mat = new THREE.MeshPhongMaterial( {'color': 0xffffff, 'transparent':true, 'opacity':0.8, 'blending':THREE.AdditiveBlending } );
		self.shaded_border = m = new THREE.Mesh( geo, mat );
		r.add( m );
		m.position.z -= 12
		m.castShadow = true;
		m.receiveShadow = true;

		geo = new THREE.BoxGeometry( 1.1, 1.1, 1 );
		mat = new THREE.MeshBasicMaterial( {'color': 0x00ffff, 'transparent':true, 'opacity':0.18, 'blending':THREE.AdditiveBlending } );
		self.glowing_border = m = new THREE.Mesh( geo, mat );
		r.add( m );
		m.position.z -= 2

		geo = new THREE.BoxGeometry( 1.1, 1.1, 50 );
		mat = new THREE.MeshBasicMaterial( {'color': 0x00ffff, 'transparent':true, 'opacity':0.28, 'blending':THREE.AdditiveBlending, 'wireframe':true } );
		m = new THREE.Mesh( geo, mat );
		r.add( m );
		m.position.z -= 40


		geo = new THREE.BoxGeometry( 0.025, 0.5, 30 );
		mat = new THREE.MeshPhongMaterial( {'color': 0xffffff } );
		self.right_bar = m = new THREE.Mesh( geo, mat );
		r.add( m );
		m.position.y += 0.3
		m.position.x -= 0.55
		m.position.z -= 10
		m.castShadow = true;

		geo = new THREE.BoxGeometry( 0.9, 0.1, 20 );
		mat = new THREE.MeshPhongMaterial( color=0xffff00, transparent=True, opacity=0.84 );
		self.footer = m = new THREE.Mesh( geo, mat );
		r.add( m );
		m.position.y -= 0.6
		m.position.z -= 5
		m.castShadow = true;


	def update(self):
		if self.shadow.element.parentNode:
			self.shadow.element.parentNode.removeChild( self.shadow.element )

		if self.active and self.object.position.y < 400:
			self.object.position.y += 10

		self.root.position.copy( self.object.position )
		self.root.rotation.copy( self.object.rotation )

		self.shadow.position.copy( self.object.position )
		self.shadow.rotation.copy( self.object.rotation )

		w = self.element.clientWidth * 0.01
		h = self.element.clientHeight * 0.01

		self.mask.scale.x = w*99
		self.mask.scale.y = h*99

		self.shadow.element = self.element.cloneNode()  ## this is just to display content

		a = self.element.getElementsByTagName('SELECT')
		b = self.shadow.element.getElementsByTagName('SELECT')
		c = {}
		for sel in b:
			c[ sel.getAttribute('id') ] = sel

		for sel in a:
			clone = c[ sel.getAttribute('id') ]
			clone.selectedIndex = sel.selectedIndex
			#clone.scrollTop = sel.scrollTop  ## this will not work to sync scrollbars


		a = self.element.getElementsByTagName('TEXTAREA')
		b = self.shadow.element.getElementsByTagName('TEXTAREA')
		c = {}
		for sel in b:
			c[ sel.getAttribute('id') ] = sel

		for sel in a:
			c[ sel.getAttribute('id') ].value = sel.value


		## insert lazy loading images into shadow dom ##
		images = self.shadow.element.getElementsByTagName('IMG')
		for img in images:
			if img.src in self.shadow_images:
				lazy = self.shadow_images[ img.src ]
				img.parentNode.replaceChild(lazy, img)
			else:
				self.shadow_images[ img.src ] = img




camera = scene = renderer = None
geometry = material = mesh = None
scene2 = renderer2 = renderer3 = None
controls = gizmo = composer = None
Elements = []

init();
animate();

def init():
	global camera, scene, scene2, scene3, renderer, renderer2, renderer3
	global geometry, material, mesh
	global controls, gizmo, composer

	SCREEN_WIDTH = window.innerWidth
	SCREEN_HEIGHT = window.innerHeight

	camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 10000 );
	camera.position.set( 200, 150, 800 );

	controls = new THREE.TrackballControls( camera );
	camera.smooth_target = controls.target.clone()

	controls.rotateSpeed = 1.0;
	controls.zoomSpeed = 1.2;
	controls.panSpeed = 0.8;

	controls.noZoom = false;
	controls.noPan = false;

	controls.staticMoving = false;
	controls.dynamicDampingFactor = 0.3;

	controls.keys = [ 65, 83, 68 ];

	scene = new THREE.Scene();
	scene3 = new THREE.Scene();



	geometry = new THREE.BoxGeometry( 800, 60, 3800 );
	material = new THREE.MeshPhongMaterial( color=0xc1c1c1, transparent=true, opacity=0.27 );
	mesh = new THREE.Mesh( geometry, material );
	mesh.position.z = -400
	#mesh.position.y = -300
	scene.add( mesh );
	mesh.receiveShadow = true;

	renderer = new THREE.WebGLRenderer(alpha=True);
	renderer.shadowMapEnabled = true
	renderer.shadowMapType = THREE.PCFSoftShadowMap
	renderer.shadowMapSoft = true


	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.domElement.style.position = 'absolute';
	renderer.domElement.style.top = 0;
	renderer.domElement.style.zIndex = 1;

	gizmo = new THREE.TransformControls( camera, renderer.domElement )
	scene.add( gizmo )

	light = new(
		THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 )
	)
	light.position.set( 0, 1400, 400 )
	light.target.position.set( 0, 0, 0 )

	light.castShadow = True
	light.shadowCameraNear = 400
	light.shadowCameraFar = 1800
	light.shadowCameraFov = 64
	light.shadowCameraVisible = True

	light.shadowBias = 0.0001
	light.shadowDarkness = 0.4

	light.shadowMapWidth = 512
	light.shadowMapHeight = 512

	scene.add( light );

	global pointlight
	pointlight = new( THREE.PointLight(0xffffff, 2, 500) )
	pointlight.position.set( 10, 100, 300 )
	scene.add( pointlight )


	//
	renderer.sortObjects = false
	renderer.autoClear = false

	renderTarget = new(
		THREE.WebGLRenderTarget(
			SCREEN_WIDTH, 
			SCREEN_HEIGHT, 
			minFilter = THREE.LinearFilter, 
			magFilter = THREE.LinearFilter, 
			format = THREE.RGBAFormat,  ## RGBA format is required to composite over css3d render
			stencilBuffer = false
		)
	)


	hblur = new(THREE.ShaderPass( THREE.HorizontalTiltShiftShader ))
	vblur = new(THREE.ShaderPass( THREE.VerticalTiltShiftShader ))

	bluriness = 1.7;
	hblur.uniforms[ 'h' ].value = bluriness / SCREEN_WIDTH;
	vblur.uniforms[ 'v' ].value = bluriness / SCREEN_HEIGHT;

	hblur.uniforms[ 'r' ].value = 0.1
	vblur.uniforms[ 'r' ].value = 0.1


	composer = new(THREE.EffectComposer( renderer, renderTarget ))

	renderModel = new(THREE.RenderPass( scene, camera ))

	vblur.renderToScreen = true;
	composer.addPass( renderModel );
	composer.addPass( hblur );
	composer.addPass( vblur );


	scene2 = new THREE.Scene();

	test_options = ['javascript', 'python']
	for i in range(15):
		test_options.append( 'some-option-'+i )

	def onclick():
		this.firstChild.nodeValue='run script'
		this.setAttribute('class', 'btn btn-warning btn-small')
		this.parentNode.appendChild(document.createTextNode(' mode:'))
		this.parentNode.appendChild( this.element3D.create_select_dropdown(test_options) )
		this.parentNode.appendChild(document.createElement('br'))

		con = document.createElement('div')
		this.parentNode.appendChild(con)
		ta = create_textarea()
		con.appendChild( ta )

		pointlight.position.copy( this.element3D.object.position )
		pointlight.position.z += 40
		gizmo.attach( this.element3D.right_bar )
		camera.smooth_target.copy( this.element3D.object.position )
		camera.smooth_target.y = 300
		print(camera.smooth_target)
		this.element3D.active=True

		## helper variables for eval ##
		container = con
		object = this.element3D
		def click2(evt):
			eval( ta.value )
		this.onclick = click2


	for i in range(10):

		var element = document.createElement( 'div' );
		element.setAttribute('class', 'well')
		#element.style.background = new THREE.Color( Math.random() * 0xffffff ).getStyle();
		b = document.createElement('button')
		b.appendChild(document.createTextNode('click me'))
		b.setAttribute('class', 'btn btn-inverse btn-small')
		b.onclick = onclick
		element.appendChild(b)

		x = Math.random() * 400 - 100;
		y = Math.random() * 200 + 100;
		z = Math.random() * 1800 - 1000;

		e = Element3D( element, scene, scene2, scene3, [x,y,z], [1,1,1] )
		Elements.append( e )
		b.element3D = e


	renderer2 = new THREE.CSS3DRenderer();
	renderer2.setSize( window.innerWidth, window.innerHeight );
	renderer2.domElement.style.position = 'absolute';
	renderer2.domElement.style.top = 0;
	renderer2.domElement.style.zIndex = 0;
	document.body.appendChild( renderer2.domElement );

	renderer3 = new THREE.CSS3DRenderer();
	renderer3.setSize( window.innerWidth, window.innerHeight );
	renderer3.domElement.style.position = 'absolute';
	renderer3.domElement.style.top = 0;
	renderer3.domElement.style.opacity = 0.28;
	renderer3.domElement.style.zIndex=200;

	document.body.appendChild( renderer2.domElement );
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( renderer3.domElement );



def animate():

	requestAnimationFrame( animate );

	gizmo.update()

	d = camera.smooth_target.clone()
	d.sub(controls.target)
	controls.target.add( d.multiplyScalar(0.03) )
	controls.update();

	for e in Elements:
		#e.object.rotation.z += 0.001
		e.update()

	renderer2.render( scene2, camera );

	renderer.clear()
	composer.render( scene, camera )

	renderer3.render( scene3, camera );


		</script>
	</body>
</html>
